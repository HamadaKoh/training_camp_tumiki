# TASK-101: Express + Socket.IOサーバー基本設定 - TDDテストケース洗い出し

## 開発言語・フレームワーク

- **プログラミング言語**: TypeScript
  - **言語選択の理由**: 型安全性によるバグ防止、Express/Socket.IOとの親和性
  - **テストに適した機能**: 型チェックによる安全なテストコード作成、インターフェース定義による明確なAPI仕様
- **テストフレームワーク**: Jest + Supertest
  - **フレームワーク選択の理由**: Node.js標準的テストツール、HTTP APIテストに最適、Socket.IOテストサポート
  - **テスト実行環境**: Docker環境でのPostgreSQL接続、モック化可能なアーキテクチャ
- 🟢 既存プロジェクトの技術スタック（REQ-402）に準拠、実装済みのパッケージ構成

## 1. 正常系テストケース（基本的な動作）

### 1.1 Expressサーバー起動テスト
- **テスト名**: Expressサーバーが正常に起動できる
  - **何をテストするか**: Express アプリケーションの初期化と起動処理
  - **期待される動作**: サーバーが指定ポートでリスニング開始
- **入力値**: 環境変数 PORT=3000
  - **入力データの意味**: デフォルトポートでのサーバー起動を確認
- **期待される結果**: サーバー起動成功、エラーなし
  - **期待結果の理由**: 基本的なWebサーバー機能の動作保証
- **テストの目的**: Express基盤の正常性確認
  - **確認ポイント**: ポートバインディング、プロセス継続性
- 🟢 要件定義書のサーバー起動要件に基づく

### 1.2 ヘルスチェックAPI正常応答テスト
- **テスト名**: GET /health が正常なヘルスチェック応答を返す
  - **何をテストするか**: ヘルスチェックエンドポイントの正常動作
  - **期待される動作**: 正常なJSON応答と200ステータスコード返却
- **入力値**: `GET /health` HTTPリクエスト
  - **入力データの意味**: システム稼働状況確認のための標準的リクエスト
- **期待される結果**: 
  ```json
  {
    "status": "healthy",
    "timestamp": "2024-01-01T00:00:00.000Z",
    "services": {
      "signaling": "operational",
      "database": "operational"
    }
  }
  ```
  - **期待結果の理由**: api-endpoints.md仕様に準拠した構造化レスポンス
- **テストの目的**: 運用監視用APIの動作確認
  - **確認ポイント**: JSON構造、タイムスタンプ形式、サービス状態
- 🟢 api-endpoints.md のヘルスチェック仕様に基づく

### 1.3 Socket.IO接続確立テスト
- **テスト名**: Socket.IO クライアントが正常に接続できる
  - **何をテストするか**: WebSocket接続の確立とconnectionイベント発火
  - **期待される動作**: クライアント-サーバー間のSocket.IO接続成功
- **入力値**: Socket.IOクライアント接続リクエスト
  - **入力データの意味**: リアルタイム通信基盤への接続試行
- **期待される結果**: connection イベント発火、接続オブジェクト取得
  - **期待結果の理由**: シグナリングサーバーの基本機能である双方向通信確立
- **テストの目的**: WebSocket通信基盤の動作確認
  - **確認ポイント**: 接続成功、イベントハンドラー実行、ソケット状態
- 🟢 REQ-406（Socket.IOシグナリング）要件に基づく

### 1.4 PostgreSQL接続確認テスト
- **テスト名**: データベース接続プールが正常に確立できる
  - **何をテストするか**: PostgreSQL への接続とクエリ実行
  - **期待される動作**: DB接続成功、基本クエリ実行可能
- **入力値**: PostgreSQL接続設定（host, port, database, user, password）
  - **入力データの意味**: 本番環境相当のDB接続パラメータ
- **期待される結果**: 接続成功、`SELECT 1` クエリ実行成功
  - **期待結果の理由**: セッション記録等のデータ永続化基盤の動作保証
- **テストの目的**: データベース基盤の接続性確認
  - **確認ポイント**: 接続プール初期化、クエリ実行、エラーハンドリング
- 🟢 database-schema.sql要件とアーキテクチャ設計に基づく

### 1.5 CORS設定正常動作テスト
- **テスト名**: 許可されたオリジンからのリクエストが正常に処理される
  - **何をテストするか**: CORS設定による適切なアクセス制御
  - **期待される動作**: 許可オリジンからのリクエストが正常処理される
- **入力値**: Origin: `http://localhost:3000` でのHTTPリクエスト
  - **入力データの意味**: 開発環境での許可されたフロントエンドからのアクセス
- **期待される結果**: 正常応答、適切なCORSヘッダー付与
  - **期待結果の理由**: セキュリティ制約下での正常なクロスオリジン通信
- **テストの目的**: セキュリティ設定の正常動作確認
  - **確認ポイント**: Access-Control-Allow-Origin ヘッダー、プリフライト処理
- 🟢 NFR-103（CORS設定）要件に基づく

## 2. 異常系テストケース（エラーハンドリング）

### 2.1 データベース接続エラー時のヘルスチェック
- **テスト名**: DB接続失敗時にヘルスチェックが503エラーを返す
  - **エラーケースの概要**: PostgreSQL接続不可能な状況下でのAPI応答
  - **エラー処理の重要性**: 運用時の障害検知とサービス状態の正確な報告
- **入力値**: 不正なDB接続設定での `GET /health` リクエスト
  - **不正な理由**: 存在しないDBホスト、間違った認証情報等
  - **実際の発生シナリオ**: DB メンテナンス、ネットワーク障害、設定ミス
- **期待される結果**: HTTP 503 Service Unavailable、services.database: "error"
  - **エラーメッセージの内容**: システム管理者向けの明確な障害情報
  - **システムの安全性**: DB障害時でもサーバー自体は稼働継続
- **テストの目的**: 依存サービス障害時の適切なエラーレスポンス
  - **品質保証の観点**: 運用監視の信頼性とフェイルセーフ機能
- 🟢 要件定義書の「DB接続エラー」ケースに基づく

### 2.2 CORS違反時のアクセス拒否テスト
- **テスト名**: 未許可オリジンからのリクエストが拒否される
  - **エラーケースの概要**: 不正なオリジンからのクロスオリジンリクエスト
  - **エラー処理の重要性**: セキュリティ攻撃（CSRF等）の防止
- **入力値**: Origin: `http://malicious-site.com` でのHTTPリクエスト
  - **不正な理由**: 許可リストに含まれていない外部サイト
  - **実際の発生シナリオ**: 悪意のあるサイトからのAPI叩き、設定ミス
- **期待される結果**: CORSエラー、Access-Control-Allow-Origin ヘッダーなし
  - **エラーメッセージの内容**: ブラウザのCORSエラー表示
  - **システムの安全性**: 不正アクセスの確実な遮断
- **テストの目的**: セキュリティ境界の実効性確認
  - **品質保証の観点**: Webアプリケーションセキュリティの基本要件
- 🟡 EDGE-001の拡張推測、NFR-103要件に基づく

### 2.3 ポート競合時のサーバー起動エラー
- **テスト名**: 使用中ポートでの起動時に適切なエラーが発生する
  - **エラーケースの概要**: 既に使用中のポートでのサーバー起動試行
  - **エラー処理の重要性**: デプロイ時の設定ミス検出、運用トラブル回避
- **入力値**: 既に使用中のポート番号（例：3000）
  - **不正な理由**: 他プロセスによるポート占有
  - **実際の発生シナリオ**: 開発環境での複数サーバー起動、ポート設定重複
- **期待される結果**: EADDRINUSE エラー、プロセス終了
  - **エラーメッセージの内容**: ポート競合の明確なエラー情報
  - **システムの安全性**: 不完全な状態での稼働防止
- **テストの目的**: 環境設定エラーの検出機能確認
  - **品質保証の観点**: デプロイ自動化の信頼性向上
- 🟡 要件定義書の「ポート競合」ケースに基づく

### 2.4 Socket.IO接続タイムアウトエラー
- **テスト名**: 接続タイムアウト時に適切なエラーハンドリングが行われる
  - **エラーケースの概要**: ネットワーク不安定時のWebSocket接続失敗
  - **エラー処理の重要性**: クライアント側での適切な再接続処理誘導
- **入力値**: タイムアウト設定を短くした接続試行
  - **不正な理由**: ネットワーク遅延、サーバー過負荷
  - **実際の発生シナリオ**: モバイル通信、プロキシ環境、サーバー高負荷
- **期待される結果**: connect_error イベント発火、エラー詳細情報
  - **エラーメッセージの内容**: 再接続を促すユーザーフレンドリーな情報
  - **システムの安全性**: クライアント側での適切な状態管理
- **テストの目的**: ネットワーク障害時の復旧能力確認
  - **品質保証の観点**: リアルタイム通信の信頼性保証
- 🟡 architecture.md の通信フローに基づく推測

## 3. 境界値テストケース（最小値、最大値、null等）

### 3.1 最大同時WebSocket接続数テスト
- **テスト名**: 10人の同時Socket.IO接続が正常に処理される
  - **境界値の意味**: NFR-004要件の上限値での動作検証
  - **境界値での動作保証**: システム設計上限での安定稼働
- **入力値**: 10個の同時Socket.IO接続
  - **境界値選択の根拠**: NFR-004要件「最大10人の同時参加サポート」
  - **実際の使用場面**: 満室状態での通話ルーム利用
- **期待される結果**: 全10接続が正常確立、パフォーマンス劣化なし
  - **境界での正確性**: 接続管理、メモリ使用量、レスポンス時間の維持
  - **一貫した動作**: 1人接続時と10人接続時の機能一貫性
- **テストの目的**: システム容量限界での動作確認
  - **堅牢性の確認**: 設計上限での安定性、リソース管理の妥当性
- 🟢 NFR-004要件「最大10人の同時参加サポート」に基づく

### 3.2 11人目接続時の制限処理テスト
- **テスト名**: 11人目の接続試行時に適切な制限処理が行われる
  - **境界値の意味**: システム容量を超えた接続試行での保護機能
  - **境界値での動作保証**: 過負荷時のシステム保護とサービス品質維持
- **入力値**: 10接続確立後の11番目のSocket.IO接続試行
  - **境界値選択の根拠**: NFR-004の上限超過ケース
  - **実際の使用場面**: 人気時間帯での満室ルームへの参加試行
- **期待される結果**: 11番目の接続拒否、既存10接続への影響なし
  - **境界での正確性**: 新規接続拒否、リソース保護、エラー通知
  - **一貫した動作**: 拒否処理の確実性、既存接続の安定継続
- **テストの目的**: 容量制限機能の実効性確認
  - **堅牢性の確認**: オーバーロード保護、フェールセーフ機能
- 🟡 NFR-004要件からの妥当な推測

### 3.3 ヘルスチェックAPI応答時間境界値テスト
- **テスト名**: ヘルスチェックAPIが1秒以内に応答する
  - **境界値の意味**: NFR-003要件の応答時間上限での性能検証
  - **境界値での動作保証**: 運用監視SLAの遵守
- **入力値**: 負荷をかけた状態での `GET /health` リクエスト
  - **境界値選択の根拠**: NFR-003「1秒以内に完了」要件
  - **実際の使用場面**: 高負荷時の監視システムによるヘルスチェック
- **期待される結果**: 1000ms以内のレスポンス、正確なJSON応答
  - **境界での正確性**: 応答時間測定、JSON構造の完全性
  - **一貫した動作**: 負荷の有無に関わらない応答品質
- **テストの目的**: パフォーマンス要件の遵守確認
  - **堅牢性の確認**: 高負荷時でも運用監視機能の継続性
- 🟢 NFR-003要件「1秒以内に完了」に基づく

### 3.4 null/undefined値でのヘルスチェック構造テスト
- **テスト名**: ヘルスチェックレスポンスにnull/undefined値が含まれない
  - **境界値の意味**: JSON応答の完全性、null安全性の検証
  - **境界値での動作保証**: API契約の一貫性、クライアント側の安全性
- **入力値**: DB接続不可等の異常状態での `GET /health` リクエスト
  - **境界値選択の根拠**: エラー時でも構造化レスポンスの維持
  - **実際の使用場面**: 部分的なサービス障害時の監視データ取得
- **期待される結果**: 明確な文字列値（"error", "operational"等）、nullなし
  - **境界での正確性**: 型安全性、JSON スキーマ遵守
  - **一貫した動作**: 正常時・異常時での応答構造の統一
- **テストの目的**: API契約の完全性確認
  - **堅牢性の確認**: 異常時でもクライアント側での安全な処理継続
- 🟡 api-endpoints.md仕様からの堅牢性推測

## 品質判定

✅ **高品質**:
- テストケース分類: 正常系・異常系・境界値が網羅されている（5正常系・4異常系・4境界値）
- 期待値定義: 各テストケースの期待値が明確（JSON構造、HTTP ステータス、エラー内容）
- 技術選択: プログラミング言語・テストフレームワークが確定（TypeScript + Jest + Supertest）
- 実装可能性: 現在の技術スタックで実現可能（Express/Socket.IO/PostgreSQL基盤）

## 次のステップ

次のおすすめステップ: `/tdd-red` でRedフェーズ（失敗テスト作成）を開始します。